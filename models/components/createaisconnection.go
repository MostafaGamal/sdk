// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/MostafaGamal/sdk/internal/utils"
	"github.com/MostafaGamal/sdk/types"
	"time"
)

type Scopes string

const (
	ScopesAccounts          Scopes = "accounts"
	ScopesBalances          Scopes = "balances"
	ScopesTransactions      Scopes = "transactions"
	ScopesBeneficiaries     Scopes = "beneficiaries"
	ScopesDirectDebits      Scopes = "direct_debits"
	ScopesParties           Scopes = "parties"
	ScopesScheduledPayments Scopes = "scheduled_payments"
	ScopesStandingOrders    Scopes = "standing_orders"
)

func (e Scopes) ToPointer() *Scopes {
	return &e
}
func (e *Scopes) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "accounts":
		fallthrough
	case "balances":
		fallthrough
	case "transactions":
		fallthrough
	case "beneficiaries":
		fallthrough
	case "direct_debits":
		fallthrough
	case "parties":
		fallthrough
	case "scheduled_payments":
		fallthrough
	case "standing_orders":
		*e = Scopes(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Scopes: %v", v)
	}
}

type ConsentDetails struct {
	// The start date from which you wish to fetch data for a particular account.
	FetchStartDate *types.Date `json:"fetch_start_date,omitempty"`
	// The date and time of consent expiration.
	ExpiresAt time.Time `json:"expires_at"`
	// The types of data that are allowed to be fetched.
	Scopes []Scopes `json:"scopes"`
}

func (c ConsentDetails) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ConsentDetails) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ConsentDetails) GetFetchStartDate() *types.Date {
	if o == nil {
		return nil
	}
	return o.FetchStartDate
}

func (o *ConsentDetails) GetExpiresAt() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.ExpiresAt
}

func (o *ConsentDetails) GetScopes() []Scopes {
	if o == nil {
		return []Scopes{}
	}
	return o.Scopes
}

type Language string

const (
	LanguageAr Language = "ar"
	LanguageEn Language = "en"
)

func (e Language) ToPointer() *Language {
	return &e
}
func (e *Language) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ar":
		fallthrough
	case "en":
		*e = Language(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Language: %v", v)
	}
}

type UseCase string

const (
	UseCaseAccountAggregation            UseCase = "account_aggregation"
	UseCasePersonalFinanceManagement     UseCase = "personal_finance_management"
	UseCaseExtendedCustomerAttributes    UseCase = "extended_customer_attributes"
	UseCaseEStatement                    UseCase = "e_statement"
	UseCaseCreditRiskAssessment          UseCase = "credit_risk_assessment"
	UseCaseSmeTaxFiling                  UseCase = "sme_tax_filing"
	UseCaseEnterpriseFinancialManagement UseCase = "enterprise_financial_management"
)

func (e UseCase) ToPointer() *UseCase {
	return &e
}
func (e *UseCase) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "account_aggregation":
		fallthrough
	case "personal_finance_management":
		fallthrough
	case "extended_customer_attributes":
		fallthrough
	case "e_statement":
		fallthrough
	case "credit_risk_assessment":
		fallthrough
	case "sme_tax_filing":
		fallthrough
	case "enterprise_financial_management":
		*e = UseCase(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UseCase: %v", v)
	}
}

type CreateAisConnection struct {
	ConsentDetails *ConsentDetails `json:"consentDetails,omitempty"`
	Language       *Language       `json:"language,omitempty"`
	UseCase        *UseCase        `json:"use_case,omitempty"`
}

func (o *CreateAisConnection) GetConsentDetails() *ConsentDetails {
	if o == nil {
		return nil
	}
	return o.ConsentDetails
}

func (o *CreateAisConnection) GetLanguage() *Language {
	if o == nil {
		return nil
	}
	return o.Language
}

func (o *CreateAisConnection) GetUseCase() *UseCase {
	if o == nil {
		return nil
	}
	return o.UseCase
}
