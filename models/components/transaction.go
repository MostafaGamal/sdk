// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"github.com/MostafaGamal/sdk/internal/utils"
	"github.com/MostafaGamal/sdk/types"
	"time"
)

// TransactionType - Type of the transaction, where:<ul><li>'fee' - stands for any institution's fee (e.g., card maintenance fee).</li><li>'transfer' - stands for any transfer.</li><li>'normal' - this type is attributed to all transactions we can't determine as fee and transfer.</li></ul>
type TransactionType string

const (
	TransactionTypeNormal   TransactionType = "normal"
	TransactionTypeFee      TransactionType = "fee"
	TransactionTypeTransfer TransactionType = "transfer"
)

func (e TransactionType) ToPointer() *TransactionType {
	return &e
}
func (e *TransactionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "normal":
		fallthrough
	case "fee":
		fallthrough
	case "transfer":
		*e = TransactionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TransactionType: %v", v)
	}
}

// TransactionStatus - The status of the transaction.
type TransactionStatus string

const (
	TransactionStatusBooked  TransactionStatus = "booked"
	TransactionStatusPending TransactionStatus = "pending"
	TransactionStatusFuture  TransactionStatus = "future"
)

func (e TransactionStatus) ToPointer() *TransactionStatus {
	return &e
}
func (e *TransactionStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "booked":
		fallthrough
	case "pending":
		fallthrough
	case "future":
		*e = TransactionStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TransactionStatus: %v", v)
	}
}

// SourceType - Whether the transaction is a credit or a debit entry.
type SourceType string

const (
	SourceTypeCredit SourceType = "credit"
	SourceTypeDebit  SourceType = "debit"
)

func (e SourceType) ToPointer() *SourceType {
	return &e
}
func (e *SourceType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "credit":
		fallthrough
	case "debit":
		*e = SourceType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SourceType: %v", v)
	}
}

// TransactionOptional - Optional data associated with the transaction.<br /><br /><strong>Note:</strong> `optional` parameter will always be present, but the array may be empty, or it may contain all or some of the parameters listed below.
type TransactionOptional struct {
	// Type of the transaction, where:<ul><li>'fee' - stands for any institution's fee (e.g., card maintenance fee).</li><li>'transfer' - stands for any transfer.</li><li>'normal' - this type is attributed to all transactions we can't determine as fee and transfer.</li></ul>
	Type *TransactionType `json:"type,omitempty"`
	// The status of the transaction.
	Status *TransactionStatus `json:"status,omitempty"`
	// Transaction's additional description.
	AdditionalDescription *string `json:"additional_description,omitempty"`
	// The number of the cheque.
	ChequeNumber *string `json:"cheque_number,omitempty"`
	// Whether the transaction amount was converted into a different currency or not.
	InternalCurrencyConvertion *bool `json:"internal_currency_convertion,omitempty"`
	// The exchange rate that was used for converting the transaction amount.
	InternalCurrencyConvertionExchangeRate *float32 `json:"internal_currency_convertion_exchange_rate,omitempty"`
	// The original transaction's amount.
	SourceAmount *float32 `json:"source_amount,omitempty"`
	// The original currency of the transaction.
	SourceCurrencyCode *string `json:"source_currency_code,omitempty"`
	// Transaction identifier on the institution's end.
	SourceID *string `json:"source_id,omitempty"`
	// Institution record number.
	SourceRecordNumber *string `json:"source_record_number,omitempty"`
	// The category of the transaction returned by the institution.
	SourceCategory *string `json:"source_category,omitempty"`
	// The subcategory of the transaction returned by the institution.
	SourceSubCategory *string `json:"source_sub_category,omitempty"`
	// Whether the transaction is a credit or a debit entry.
	SourceType *SourceType `json:"source_type,omitempty"`
	// Time when the transaction was made.
	SourceTime *string `json:"source_time,omitempty"`
	// Date when the transaction is officially recorded and processed by the institution.
	PostingDate *types.Date `json:"posting_date,omitempty"`
	// Time when the transaction is officially recorded and processed by the institution.
	PostingTime *string `json:"posting_time,omitempty"`
	// A unique identifier set by the merchant. Usually used for reconciliation.
	EndToEndID *string `json:"end_to_end_id,omitempty"`
	// Transaction's MCC (Merchant Category Code).
	Mcc *string `json:"mcc,omitempty"`
	// The balance of the account after the transaction was imported.
	ClosingBalance *float32 `json:"closing_balance,omitempty"`
	// The balance of the account before the transaction was imported.
	OpeningBalance *float32 `json:"opening_balance,omitempty"`
	// Payee IBAN/account number.
	Payee *string `json:"payee,omitempty"`
	// Additional information about the payee.
	PayeeInformation *string `json:"payee_information,omitempty"`
	// Payer IBAN/account number.
	Payer *string `json:"payer,omitempty"`
	// Additional information about the payer.
	PayerInformation *string `json:"payer_information,omitempty"`
	// User-defined information that is assigned to a transaction record in the bank or e-wallet interface.
	Tags []string `json:"tags,omitempty"`
}

func (t TransactionOptional) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TransactionOptional) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *TransactionOptional) GetType() *TransactionType {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *TransactionOptional) GetStatus() *TransactionStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *TransactionOptional) GetAdditionalDescription() *string {
	if o == nil {
		return nil
	}
	return o.AdditionalDescription
}

func (o *TransactionOptional) GetChequeNumber() *string {
	if o == nil {
		return nil
	}
	return o.ChequeNumber
}

func (o *TransactionOptional) GetInternalCurrencyConvertion() *bool {
	if o == nil {
		return nil
	}
	return o.InternalCurrencyConvertion
}

func (o *TransactionOptional) GetInternalCurrencyConvertionExchangeRate() *float32 {
	if o == nil {
		return nil
	}
	return o.InternalCurrencyConvertionExchangeRate
}

func (o *TransactionOptional) GetSourceAmount() *float32 {
	if o == nil {
		return nil
	}
	return o.SourceAmount
}

func (o *TransactionOptional) GetSourceCurrencyCode() *string {
	if o == nil {
		return nil
	}
	return o.SourceCurrencyCode
}

func (o *TransactionOptional) GetSourceID() *string {
	if o == nil {
		return nil
	}
	return o.SourceID
}

func (o *TransactionOptional) GetSourceRecordNumber() *string {
	if o == nil {
		return nil
	}
	return o.SourceRecordNumber
}

func (o *TransactionOptional) GetSourceCategory() *string {
	if o == nil {
		return nil
	}
	return o.SourceCategory
}

func (o *TransactionOptional) GetSourceSubCategory() *string {
	if o == nil {
		return nil
	}
	return o.SourceSubCategory
}

func (o *TransactionOptional) GetSourceType() *SourceType {
	if o == nil {
		return nil
	}
	return o.SourceType
}

func (o *TransactionOptional) GetSourceTime() *string {
	if o == nil {
		return nil
	}
	return o.SourceTime
}

func (o *TransactionOptional) GetPostingDate() *types.Date {
	if o == nil {
		return nil
	}
	return o.PostingDate
}

func (o *TransactionOptional) GetPostingTime() *string {
	if o == nil {
		return nil
	}
	return o.PostingTime
}

func (o *TransactionOptional) GetEndToEndID() *string {
	if o == nil {
		return nil
	}
	return o.EndToEndID
}

func (o *TransactionOptional) GetMcc() *string {
	if o == nil {
		return nil
	}
	return o.Mcc
}

func (o *TransactionOptional) GetClosingBalance() *float32 {
	if o == nil {
		return nil
	}
	return o.ClosingBalance
}

func (o *TransactionOptional) GetOpeningBalance() *float32 {
	if o == nil {
		return nil
	}
	return o.OpeningBalance
}

func (o *TransactionOptional) GetPayee() *string {
	if o == nil {
		return nil
	}
	return o.Payee
}

func (o *TransactionOptional) GetPayeeInformation() *string {
	if o == nil {
		return nil
	}
	return o.PayeeInformation
}

func (o *TransactionOptional) GetPayer() *string {
	if o == nil {
		return nil
	}
	return o.Payer
}

func (o *TransactionOptional) GetPayerInformation() *string {
	if o == nil {
		return nil
	}
	return o.PayerInformation
}

func (o *TransactionOptional) GetTags() []string {
	if o == nil {
		return nil
	}
	return o.Tags
}

type EnrichmentStatus string

const (
	EnrichmentStatusNotEnriched EnrichmentStatus = "not-enriched"
	EnrichmentStatusPending     EnrichmentStatus = "pending"
	EnrichmentStatusFailed      EnrichmentStatus = "failed"
	EnrichmentStatusEnriched    EnrichmentStatus = "enriched"
)

func (e EnrichmentStatus) ToPointer() *EnrichmentStatus {
	return &e
}
func (e *EnrichmentStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "not-enriched":
		fallthrough
	case "pending":
		fallthrough
	case "failed":
		fallthrough
	case "enriched":
		*e = EnrichmentStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EnrichmentStatus: %v", v)
	}
}

type Transaction struct {
	ID           *int64 `json:"id,omitempty"`
	ConnectionID *int64 `json:"connection_id,omitempty"`
	AccountID    *int64 `json:"account_id,omitempty"`
	AttemptID    *int64 `json:"attempt_id,omitempty"`
	// Transaction's currency code.
	CurrencyCode *string `json:"currency_code,omitempty"`
	// Transaction's description.
	Description *string `json:"description,omitempty"`
	// Transaction's amount.<br /><br /><strong>Note:</strong> Negative amounts refer to debit transactions, while positive - to credit transactions.
	Amount *float32 `json:"amount,omitempty"`
	// The date when the transaction was made.
	MadeOn *types.Date `json:"made_on,omitempty"`
	// Whether the transaction is duplicated or not.
	IsDuplicated *bool `json:"is_duplicated,omitempty"`
	// Optional data associated with the transaction.<br /><br /><strong>Note:</strong> `optional` parameter will always be present, but the array may be empty, or it may contain all or some of the parameters listed below.
	Optional         *TransactionOptional `json:"optional,omitempty"`
	EnrichmentStatus *EnrichmentStatus    `json:"enrichment_status,omitempty"`
	// When available, provides category name based on the data enrichment model
	CategoryName *string `json:"category_name,omitempty"`
	// Sub-category name based on the data enrichment model
	SubCategoryName *string `json:"sub_category_name,omitempty"`
	// Merchant name based on the data enrichment model
	MerchantName *string `json:"merchant_name,omitempty"`
	// Merchant logo based on the data enrichment model
	MerchantLogo *string `json:"merchant_logo,omitempty"`
	// The timestamp when the transaction was fetched for the first time, in RFC 3339 format.
	CreatedAt *time.Time `json:"created_at,omitempty"`
	// The timestamp when the transaction was last updated, in RFC 3339 format.
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

func (t Transaction) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Transaction) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Transaction) GetID() *int64 {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Transaction) GetConnectionID() *int64 {
	if o == nil {
		return nil
	}
	return o.ConnectionID
}

func (o *Transaction) GetAccountID() *int64 {
	if o == nil {
		return nil
	}
	return o.AccountID
}

func (o *Transaction) GetAttemptID() *int64 {
	if o == nil {
		return nil
	}
	return o.AttemptID
}

func (o *Transaction) GetCurrencyCode() *string {
	if o == nil {
		return nil
	}
	return o.CurrencyCode
}

func (o *Transaction) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Transaction) GetAmount() *float32 {
	if o == nil {
		return nil
	}
	return o.Amount
}

func (o *Transaction) GetMadeOn() *types.Date {
	if o == nil {
		return nil
	}
	return o.MadeOn
}

func (o *Transaction) GetIsDuplicated() *bool {
	if o == nil {
		return nil
	}
	return o.IsDuplicated
}

func (o *Transaction) GetOptional() *TransactionOptional {
	if o == nil {
		return nil
	}
	return o.Optional
}

func (o *Transaction) GetEnrichmentStatus() *EnrichmentStatus {
	if o == nil {
		return nil
	}
	return o.EnrichmentStatus
}

func (o *Transaction) GetCategoryName() *string {
	if o == nil {
		return nil
	}
	return o.CategoryName
}

func (o *Transaction) GetSubCategoryName() *string {
	if o == nil {
		return nil
	}
	return o.SubCategoryName
}

func (o *Transaction) GetMerchantName() *string {
	if o == nil {
		return nil
	}
	return o.MerchantName
}

func (o *Transaction) GetMerchantLogo() *string {
	if o == nil {
		return nil
	}
	return o.MerchantLogo
}

func (o *Transaction) GetCreatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Transaction) GetUpdatedAt() *time.Time {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}
